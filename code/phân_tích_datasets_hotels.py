# -*- coding: utf-8 -*-
"""Phân_tích_datasets_hotels.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gApWHekp0MIVYe5r7H5fNf4VuxieNHta
"""

from textblob import TextBlob
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.feature_extraction import text
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.metrics import accuracy_score
import seaborn as sns

df = pd.read_csv("datasets_hotels.csv")
df.head(5)

df.isna().sum()

#so sanh giua rating va price
import plotly.graph_objects as go
fig = go.Figure([go.Bar(x=df.rating.value_counts().index, y=df.price.value_counts().tolist())])
fig.update_layout(
    title="Biểu đồ so sánh giá khách sạn và độ rating",
    xaxis_title="Rating",
    yaxis_title="Giá")
fig.show()

import plotly.graph_objects as go
fig = go.Figure([go.Bar(x=df.rating_title.value_counts().index, y=df.rating_title.value_counts().tolist())])
fig.update_layout(
    title="Phân bố đánh giá người dùng",
    xaxis_title="Đánh giá",
    yaxis_title="Số lượng")
fig.show()

import plotly.graph_objects as go
fig = go.Figure([go.Bar(x=df.rating.value_counts().index, y=df.rating_title.value_counts().tolist())])
fig.update_layout(
    title="So sánh rating với rating title",
    xaxis_title="Rating",
    yaxis_title="Rating title")
fig.show()

import plotly.graph_objects as go
fig = go.Figure([go.Bar(x=df.number_of_ratings.value_counts().index, y=df.number_of_ratings.value_counts().tolist())])
fig.update_layout(
    title="Phân bố số lượng đánh giá",
    xaxis_title="Giá trị phân bố",
    yaxis_title="Số lượng")
fig.show()

def sentiment(price):
  if price in range(0,10):
    return 'Giá Thấp'
  elif price in range(11,20):
    return 'Giá Trung Bình'
  else:
    return 'Giá Cao' 

df['price_list'] = df['price'].apply(sentiment)
df.head()

#plt.figure(figsize=(25,20))
sns.countplot(x= df['price_list'])

#plt.figure(figsize=(16,4))
sns.countplot(x= df['rating_title'])

plt.figure(figsize=(16,4))
sns.countplot(x= df['location'])

df_group = df.groupby('room_type')
print(df_group.sum())

df = pd.read_csv("datasets_reviews_hotels.csv")
df.head(5)

sentiments = []
for review in df['reviews']:
    if TextBlob(review).sentiment.polarity < 0:
        sentiments.append("Negative")
    if TextBlob(review).sentiment.polarity == 0:
        sentiments.append("Neutral")
    if TextBlob(review).sentiment.polarity > 0:
        sentiments.append("Positive")
df["Sentiment"] = np.array(sentiments)

df

df['rating'].value_counts()

plt.figure(figsize=(16,4))
sns.countplot(x= df['rating'])

plt.figure(figsize=(15,5))
plt.subplot(1,2,1)
x_axis,counts = np.unique(df['rating'],return_counts=True)
plt.bar([str(i) for i in x_axis],counts)
plt.title("Rating vs Counts")
plt.xlabel("Rating")
plt.ylabel("Count")

plt.subplot(1,2,2)
x_axis,counts = np.unique(df['Sentiment'],return_counts=True)
plt.bar(x_axis,counts)
plt.title("Sentiment vs Counts")
plt.xlabel("Sentiment")
plt.ylabel("Count")
plt.tight_layout()

df['Word_count']= df['reviews'].map(lambda x: len(x.split()))
df

sns.lineplot(x='rating', data=df, y='Word_count')

from textblob import TextBlob

def polarity(text):
    blob= TextBlob(text)
    blob.sentiment
    polarity= blob.sentiment.polarity
    
    return polarity

def subjectivity(text):
    blob= TextBlob(text)
    blob.sentiment
    subjectivity= blob.sentiment.subjectivity
    
    return subjectivity

df['Polarity']= df['reviews'].apply(polarity)
df['Subjectivity']= df['reviews'].apply(subjectivity)
df

sns.distplot(df['Polarity'])

sns.distplot(df['Subjectivity'])

import plotly.graph_objects as go
fig = go.Figure([go.Bar(x=df.rating.value_counts().index, y=df.Polarity.value_counts().tolist())])
fig.update_layout(
    title="Mức độ đánh giá so với Polarity",
    xaxis_title="Rating",
    yaxis_title="Polarity")
fig.show()

import plotly.graph_objects as go
fig = go.Figure([go.Bar(x=df.rating.value_counts().index, y=df.Subjectivity.value_counts().tolist())])
fig.update_layout(
    title="Mức độ đánh giá so với Subjectivity",
    xaxis_title="Rating",
    yaxis_title="Subjectivity")
fig.show()

#import matplotlib.pyplot as plt
#plt.plot(history.history['loss'], label='loss')
#plt.plot(history.history['val_loss'], label='val_loss')
#plt.legend()
#plt.show()
#plt.savefig("Loss plot.jpg")

import spacy
nlp= spacy.load('en_core_web_sm')

def preprocess(text):
    lower= text.lower()
    doc= nlp(lower)
    tokens= [token.lemma_ for token in doc ]
    a_lemma= [lemma for lemma in tokens if lemma not in spacy.lang.en.stop_words.STOP_WORDS and lemma.isalpha()]
    return " ".join(a_lemma)

df['Review_new']= df['reviews'].apply(preprocess)

df

rev= " ".join([review for review in df['Review_new']])
rev[:2000]

from wordcloud import WordCloud
plt.figure(figsize=(15,10))
wc= WordCloud(max_words=200,height= 800, width=1000 ,background_color='black').generate(rev)
plt.imshow(wc)

def sentiment(Review_new):
    if Review_new>=3:
        return '1'
    else:
        return '0'
df['Sentiment']= df['rating'].apply(sentiment)
df

#df.to_csv('2.csv',encoding="utf-8-sig",index=False)
#len(data)

#nationsGrp.groups

#subsetting dataset
#data=df[['id_motels','Sentiment']]
#data

#dt=data.query('id_motels=="16"')
#dt

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from nltk import word_tokenize

X= df['Review_new']
y= df['Sentiment']

X_train, X_test,y_train, y_test= train_test_split(X, y, test_size=0.25, stratify=y)

X_train

y_train

import nltk
nltk.download('punkt')

tfidf= TfidfVectorizer(max_features=10000, tokenizer= word_tokenize,ngram_range=(1,2) )
X_train_transformed= tfidf.fit_transform(X_train.values)
X_test_transformed= tfidf.transform(X_test.values)

X_train_transformed.shape

from sklearn.ensemble import RandomForestClassifier

rfc= RandomForestClassifier()
rfc.fit(X_train_transformed, y_train)
y_pred= rfc.predict(X_test_transformed)

rfc.score(X_test_transformed, y_test)

from sklearn.linear_model import LogisticRegression

lr= LogisticRegression()
lr.fit(X_train_transformed, y_train)
y_pred= lr.predict(X_test_transformed)

lr.score(X_test_transformed, y_test)

vectorizer = TfidfVectorizer(stop_words=text.ENGLISH_STOP_WORDS)
X_train,X_test,Y_train,Y_test = train_test_split(vectorizer.fit_transform(df['Review_new']).toarray(),
                                                 df['Sentiment'].values,
                                                 test_size = 0.2,
                                                 random_state=42)

clf = LogisticRegression(solver='liblinear',random_state=0)
clf.fit(X_train,Y_train)
print("Train Accuracy : {:.2f} %".format(accuracy_score(clf.predict(X_train),Y_train)*100))
print("Test Accuracy  : {:.2f} %".format(accuracy_score(clf.predict(X_test),Y_test)*100))

for i in range (0,100):
  vectorizer = TfidfVectorizer(stop_words=text.ENGLISH_STOP_WORDS)
  X_train,X_test,Y_train,Y_test = train_test_split(vectorizer.fit_transform(df['Review_new']).toarray(),
                                                 df['Sentiment'].values,
                                                 test_size = 0.3,
                                                 random_state=42 + i)
  
  clf = LogisticRegression(solver='liblinear',random_state= i)
  clf.fit(X_train,Y_train)
  
  rfc= RandomForestClassifier()
  rfc.fit(X_train,Y_train)
  print("Lân thứ ", i)
  print("Train Accuracy LogisticRegression : {:.2f} %".format(accuracy_score(clf.predict(X_train),Y_train)*100))
  print("Test Accuracy  LogisticRegression: {:.2f} %".format(accuracy_score(clf.predict(X_test),Y_test)*100))
  print("Train Accuracy RandomForestClassifier: {:.2f} %".format(accuracy_score(rfc.predict(X_train),Y_train)*100))
  print("Test Accuracy  RandomForestClassifier: {:.2f} %".format(accuracy_score(rfc.predict(X_test),Y_test)*100))
  print("\n")

empty = []

for i in df.itertuples():
    if type(review) == str:
        if review.isspace():
            empty.append(i) # lấy chỉ mục của bài đánh giá 
            
            
print(f"There are total {len(empty)} empty strings as review.")

# gán Id cho tất cả các từ duy nhất có trong cột Review_new
from tensorflow.keras.preprocessing.text import Tokenizer

tokenizer = Tokenizer()

tokenizer.fit_on_texts(df['Review_new'])

# tổng số từ duy nhất có trong tất cả các bản tóm tắt được kết hợp
vocab_size = len(tokenizer.index_word)

# tokeninzer.index_word là một từ điển mà người dùng có thể xem tất cả các từ duy nhất và ID của chúng.

print(f'There are total {vocab_size} unique words present')

# thay thế từng từ trong bài đánh giá bằng mã thông báo tương ứng
sequences = tokenizer.texts_to_sequences(df['Review_new'])
tokenizer.index_word

# tạo mô hình RNN-NLP, mỗi đầu vào phải có độ dài bằng nhau
from tensorflow.keras.preprocessing.sequence import pad_sequences

# độ dài của đầu vào là 100. Vì vậy, nếu bất kỳ đầu vào nào có độ dài nhỏ hơn 100, các số 0 thừa sẽ được thêm vào
# Bất kỳ đầu vào nào có độ dài hơn 100 sẽ bị loại bỏ từ thừa.
sequences_padded = pad_sequences(sequences,maxlen=100,padding='post')
sequences_padded

df[['Sentiment']] = df[['Sentiment']].astype('int')
df['Sentiment'].unique()
y = np.array(df['Sentiment'])
y

# chia dữ liệu thành nhóm test và nhóm thử nghiệm
from sklearn.model_selection import train_test_split

X_train,X_test,y_train,y_test = train_test_split(sequences_padded,y,test_size=0.3)

#Các thư viện để tạo và đào tạo mô hình
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import LSTM
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Embedding

# Model
max_len = 100 # độ dài của mỗi đầu vào
embedding_size = 32

model = Sequential()

model.add(Embedding(vocab_size+1,embedding_size,input_length = max_len))

model.add(LSTM(150,return_sequences=True))
model.add(Dropout(0.2))

model.add(LSTM(150))
model.add(Dropout(0.2))

model.add(Dense(256,activation='relu'))
model.add(Dropout(0.2))

model.add(Dense(128,activation='relu'))

model.add(Dense(1,activation='sigmoid'))

model.compile(optimizer='adam',loss='binary_crossentropy',metrics=['accuracy'])

model.summary()

# train our model
model.fit(X_train,y_train,validation_data=(X_test,y_test),epochs=15,batch_size=64)

metrics = pd.DataFrame(model.history.history)

metrics

metrics[['loss','val_loss']].plot()
metrics[['accuracy','val_accuracy']].plot()

# dự đoán về một vài bài đánh giá
neg_review = ['Đã dành 4 đêm ở đây từ . Mọi thứ về khách sạn này đều tuyệt vời. Không thể giới thiệu nó đủ cao. Nhân viên đều tuyệt vời. Phòng không tì vết. Ăn sáng mọi thứ bạn có thể muốn. Quán bar rất tốt. Tôi đã ở lại một số tiểu thuyết, đây là tốt nhất. Cũng hoàn hảo ']

# This is a negative review.Let's check if the model is able to predict it

# mã hóa và thực hiện pad_sequence để làm đúng định dạng được chấp nhận bởi mô hình
neg_review_token = tokenizer.texts_to_sequences(neg_review)

# padding
neg_review_padded = pad_sequences(neg_review_token,maxlen=100,padding='post')

review_predict = (model.predict(neg_review_padded)>0.5).astype('int32')

# 1 là đánh giá tích cực và 0 là đánh giá tiêu cực
if review_predict[0] == 0:
    print("Đó là một đánh giá tiêu cực")
else:
    print("Đó là một đánh giá tích cực")

# thử một cái khác
pos_review = ["Tôi ở 4 đêm chỉ trong tuần qua! Ban đầu tôi đã đặt một căn phòng cao cấp nhưng đã quyết định nâng cấp lên một bộ Junior trong ngày đầu tiên để có một khoản phí danh nghĩa vì tôi muốn có một cái nhìn về Sacre ... Khác"]

# Tokenization
pos_review = tokenizer.texts_to_sequences(pos_review)

# padding
pos_review = pad_sequences(pos_review,maxlen=100,padding='post')

# prediction
review_predict = (model.predict(pos_review)>0.5).astype('int')

if review_predict[0] == 0:
    print("Đó là một đánh giá tiêu cực")
else:
    print("Đó là một đánh giá tích cực")

# dự đoán trên X_test
prediction = (model.predict(X_test)>0.5).astype('int32')
# Đánh giá
from sklearn.metrics import classification_report
print(classification_report(y_test,prediction))